# Chapter06 プロセス・ジョブ

Linuxを含め現在のOSの多くでは，複数のプログラムを同時に並行して実行できるマルチタスク機能が搭載されています．例えば，何かのプログラム処理をしながら別のファイルを編集したり，複数人でLinuxサーバに同時にアクセスして別々の作業をすることが出来ます．あまり意識しなくてもLinuxが上手に処理の実行をしてくれますが，途中で処理を打ち切りたくなることもあると思います．そこで，6.1では，プロセスの説明とプロセスの確認方法を説明します．6.2では，ジョブについて説明します．6.3ではプロセスやジョブを終了する方法を説明します．

## 6.1 プロセス

プロセスとは動作中のプログラムです．Linuxカーネルはディスクから実行ファイルを読み出してメモリに格納し，そのメモリ内容に従ってCPUがプログラムを実行します．このメモリ上で実行状態にあるプログラムのことがプロセスになります．

Linuxカーネルが各プロセスに対してそれぞれプロセスIDを設定し，適切にプロセスを管理しています．プロセスは実行ユーザが設定されており，他人のプロセスを勝手に操作することもできないようになっています．

少し細かいですが，Linuxではプロセスは無から発生するものではなく，すでに存在している別のプロセスをもとに作成されます．例えばシェルから `whoami` コマンドを実行する場合，シェルが親プロセスとなり，シェルのプロセスから `whoami` コマンドのプロセスが子プロセスとして実行されます． (最初のプロセスはカーネル初期化後に最初に起動される `init` というものになります．)

### プロセスの表示

書式

```bash
ps <オプション>
```

オプション (BSDオプション)

- `x` : `ps` コマンドを実行したユーザのプロセスをすべて表示
- `ux` : `ps` コマンドを実行したユーザのプロセスすべてを，詳細に表示
- `ax` : すべてのユーザのプロセスを表示
- `aux` : すべてのユーザのプロセスを，詳細に表示

ハイフンが不要なことに注意してください．

例

```bash
ps aux    # コマンドを実行したユーザのプロセスを詳細に表示
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/b1cb2bc0-1e3f-4944-95a7-e2023b1618bc/3c7a644b-f69f-415e-83ca-9bbed41d1987/Untitled.png)

- USER: 実行しているユーザ
- PID: プロセスID
- %CPU・%MEM: CPUとメモリ使用率
- TIME: 実行してからの時間
- COMMAND: 実行したコマンド

## 6.2 ジョブとは

ジョブとはシェルから見た処理の単位のことです．プロセスはLinuxカーネルから見た処理の単位です．コマンドが1つだけの場合，ジョブとプロセスは同じですが， `|` (パイプ) を使って高慢度を繋いだ場合，プロセスはコマンドごとに生成されますが，ジョブはコマンドライン全体で1つになります．

下記コマンドでは，ジョブは1つですが，プロセスは2つ生成されます．

```bash
ps aux | head
```

また，ジョブはシェルごとにジョブ番号を持ちますので，ジョブ番号は重複することもあります．一方で，プロセスはシステム全体でただ一つのプロセスIDを持ちます．

シェルを使うことでジョブを一時停止させたり，バックグラウンドで実行させたりといった制御をすることができます．

### ジョブの状態

ジョブには3つの状態があります．

- 停止
    - 処理を一時的に中断している状態
- フォアグラウンド
    - ユーザが対話的に操作しながら処理が実行されている状態
- バックグラウンド
    - ユーザが対話的に操作せず処理が実行されている場合

### ジョブを停止する

フォアグラウンド状態にあるジョブを停止するには， `C-z` でできます．

例

```bash
man ls    # lsコマンドのマニュアルを表示
# Control キーを押すと， man ls コマンドが停止する
jobs    # jobの確認
vim ~/.bashrc    # ファイルを編集する
# C-z で vimコマンドを停止する
jobs
# man ls と　vim ~/.bashrc コマンドのジョブが停止している
```

### ジョブをフォアグラウンドにする

書式

```bash
fg %<ジョブ番号>
```

例 (ジョブ停止の続き)

```bash
fg %1    # man ls コマンドが画面に表示される
# q を押して，マニュアルを修了させる
fg %2    # vim コマンドをフォアグラウンドにする
# :q! でVimを修了させる
```

### ジョブをバックグラウンドにする

処理に時間がかかるものやユーザが対話的に操作する必要がないものはバックグラウンドで処理をさせることができます．

停止中のジョブをバックグラフで実行する場合， `bg` コマンドを使います．

書式

```bash
bg %<ジョブ番号>
```

最初からジョブをバックグラウンドで処理したい場合，コマンドの末尾に `&` をつけます．

例

```bash
vim ~/.bashrc & 
jobs
```

## 6.3 プロセス・ジョブを終了する

間違ったコマンドを実行したり，プログラムのバグでコマンドが操作を受け付けなくなった場合，シェルからコマンドを終了させることができます．

### ジョブの終了

フォアグラウンドジョブの場合， `C-c` をおすることでジョブを終了できます．

バックグラウンドジョブの場合， `kill` コマンドで終了させます．

`kill`コマンドの書式

```bash
kill %<ジョブ番号>
```

### プロセスの終了

バックグラウンドジョブの終了と同様に， `kill` コマンドを使います．ただし， `%` は不要です．また，他人のプロセスを勝手に終了させないように，プロセスを終了できるのはそのユーザのみです．

書式

```bash
kill <プロセスID>
```

## 補足 `kill` コマンドの本当の機能ついて

`kill` コマンドは，ジョブ・プロセスを終了させるコマンドではありません．実は「プロセスにシグナルを送信する」コマンドです．シグナルには，終了や停止，再起動があり，それを活用してジョブやプロセスを終了させていました．

書式

```bash
kill -<シグナル> <プロセスID，%job番号>
```

シグナル一覧は `kill -l` で確認することが出来ます． `kill` コマンドのデフォルトシグナルは， `TERM` (15)であり，処理を終了するシグナルになります．

## 補足: ssh接続後もバックグラウンドでジョブを実行する

`&` を利用したバックグラウンドジョブの実行では，ssh接続を終了すると，そのジョブは終了される．その理由は，接続しているsshのシェルの子プロセスとして稼働しているためである．ssh接続終了後もプロセスを稼働したい場合， `nohup` コマンドを利用する．

```bash
nohup <コマンド> &
```

すでに実行している場合，一旦バックグラウンドジョブに変更後， `disown` コマンドを利用する．

```bash
disown $<ジョブ番号>
```